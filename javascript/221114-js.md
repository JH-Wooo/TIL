# CORS

프론트엔드를 공부하면서 다른 서버의 api를 요청할때 발생하는 오류인 cors 에러를 만나게 되면, 정말 해결하기 힘들었다. 이런 에러는 왜 발생할까??

**_교차 출처 리소스공유_**(Cross-Origin Resource Sharing)는 추가 HTTTP 헤더를 사용하여, 한 출처에서 실행 중인 웹 애플리케이션이 다른 출처의 선택한 자원에 접근할 수있는 권한을 부여하도록 브라우저에 알려주는 체제다. 웹 애플리케이션은 리소스가 자신의 출처(도메인,프로토콜,포트)와 다를 때 교차 출처 HTTP 요청을 실행한다.

보안상의 이유로, 브라우저는 스크립트에서 시작한 교차 출처 HTTP 요청을 제한한다. 즉, 이 API(XMLHttpRequest와 Fetch API)를 사용하는 웹 애플리케이션은 자신의 출처와 동일한 리소스만 불러올 수 있다. 다른 출처의 리소스를 불러오려면 그 출처에서 올바른 CORS헤더를 포함한 응답을 반환해야 한다.

## 기능적 개요

교차 출처 리소스 공유 표준은 웹 브라우저에서 해당 정보를 읽는 것이 허용된 출처를 서버에서 설명 할 수 있는 새로운 HTTP 헤더를 추가함으로써 동작한다. 추가적으로, 서버 데이터에 부수 효과를 일으킬 수 있는 HTTP 요청 메서드에대해 CORS 명세는 브라우저가 요청을 options 메서드로 프리플라이트하여 지원하는 메서드를 요청하고, 서버의 허가가 떨어지면 실제 요청을 보내도록 요구한다. 또한 서버는 클라이언테에게 요청에 인증정보를 함께 보내야 한다고 알려줄 수도 있다.

CORS 실패는 오류의 원인이지만, 보안상의 이유로 JavaScript에서는 오류의 상세 정보에 접근할 수 없으며, 알 수 있는 것은 오류가 발생했다는 사실 뿐이다. 정확히 어떤것이 실패했는지 알아내려면 브라우저의 콘솔을 봐야 한다.

출처: https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS

## 출처가 무엇인가?

서버의 위치를 의미하는 https://google.com과 같은 url들은 마치 하나의 문자열 같아 보여도, 사실은 여러개의 구성 요소로 이루어져있다.

- https:// -> Protocal
- www.evan-moon.com -> Host
- /users -> Path
- ?sort=asc&page=1 -> Query String
- #foo -> Fragment

이때 출처는 Protocol과 Host, 그리고 위 그림에는 나와있지 않지만 :80, :443과 같은 포트 번호까지 모두 합친 것을 의미한다. 즉, 서버의 위치를 찾아가기 위해 필요한 가장 기본적인 것들을 합쳐놓은 것이다.

출처 내의 포트 번호는 생략이 가능한데, 이는 각 웹에서 사용하는 HTTP, HTTPS 프로토콜의 기본 포트 번호가 정해져있기 때문이다.

우리는 브라우저의 개발자 도구의 콘솔에서 Location객체가 가지고 있는 origin 프로퍼티에 접근함으로써 손 쉽게 어플리케이션이 실행되고 있는 출처를 알아낼 수도 있따.

```js
console.log(location.origin);
```

## SOP(Same-Origin Policy)

웹 생태계에는 다른 출처로의 리소스 요청을 제한하는것과 관련된 두 가지 정책이 존재한다. 한 가지는 이 포스팅의 주제인 CORS, 그리고 또 한가지는 SOP이다.

SOP는 지난 2011년 RFC 6454에 처음 등장한 보안 정책으로 말 그대록 "같은 출처에서만 리소스를 공유할 수 있다."라는 규칙을 가진 정책이다.

그러나 웹이라는 오픈스페이스 환경에서 다른 출처에 있는 리소스를 가져와서 사용하는 일은 굉장히 흔한 일이라 무작정 막을 수 도 없는 노릇이니 몇 가지 예외 조항을 두고 이 조항에 해당하는 리소스 요청은 출처가 다르더라도 허용하기로 했는데, 그 중 하나가 "CORS 정책을 지킨 리소스 요청"이다. ( CORS 등장은 2009년이라, SOP의 등장보다 빠르다.)

우리가 다른 출처로 리소스를 요청한다면 SOP 정책을 위반한 것이 되고, 거기다가 SOP의 예외 조항인 CORS 정책까지 지키지 않는다면 아예 다른 출처의 리소스를 사용할 수 없게 되는 것이다.

즉, 이렇게 다른 출처의 리소스를 사용하는 것을 제한하는 행위는 하나의 정책만으로 결정된 사항이 아니라는 의미가 되며, SOP에서 정의된 예외 조항과 CORS를 사용할 수 있는 케이스들이 맞물리지 않을 경우에는 아예 리소스 요청을 할 수 없는 케이스도 존재할 수 잇다.

근데 왜 이렇게 귀찮은 정책을 만들어서 개발자들을 괴롭히는 것일까? 어차피 개발자는 정해진 서버하고만 통신을 하도록 어플리케이션을 작성할 텐데 말이다.

## CORS와 SOP 정책이 존재하는 이유

클라이언트 어플리케이션, 특히나 웹에서 돌아가는 클라이언트 어플리케이션은 사용자의 공격에 너무나도 취약하다. 당장 브라우저의 개발자 도구만 열어도 DOM이 어떻게 작성되어 있는지, 어떤 서버와 통신하는지, 리소스의 출처는 어디인지와 같은 각종 정보들을 아무런 제재없이 열람가능하다.

이런 상황에서 다른 출처의 어플리케이션이 서로 통신하는 것에 제약이 존재하지 않는다면, 악의를 가진 사용자가 소스 코드를 구경한 후 **_CSRF(Cross-Site Request Forgery)_**나 **_XSS(Cross-Site Scripting)_**와 같은 방법을 사용하여 어플리케이션에서 코드가 실행된 것처럼 꾸며서 사용자의 정보를 탈취하기가 너무나 쉬워진다.

## 출처를 판단하는 방법

사실 두 개의 출처가 서로 같다고 판단하는 로직 자체는 굉장히 간단한데, 두 URL의 구성 요소 중 Scheme, Host, Port, 이 3가지만 동일하면 된다.

https://evan-moon.github.io:80라는 출처를 예로 들면 https:// 이라는 스킴에 evan-moon.github.io 호스트를 가지고 :80번 포트를 사용하고 있다는 것만 같다면 나머지는 전부 다르더라도 같은 출처로 인정이 된다는 것이다.
